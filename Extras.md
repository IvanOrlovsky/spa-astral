7. **Планирование: setTimeout и setInterval. Для чего они используются? В чем отличие setInterval от рекурсивного setTimeout? Отмена timeout-а и interval-а.**

    Они используются для отложенного и регулярного выполнения функции, соответственно.
    Отмена осуществляется путем методов `clearInterval` и `clearTimeout`, в которые передаются id счетчиков, а id возвращаются из `setTimeout` и `setInterval`
    Рекурсивный `setTimeout` более гибок, в нем можно настроить свою логику регулярного выполнения, менять задержку как угодно, а самое важное, что если функция выполняется долго, то при `setInterval` время её выполнения пойдет в счет задержки, и если функция выполнилась за время бОльшее, чем задержка, то она выполнится повторно немедленно, а с рекурсивным `setTimeout` будет ожидамое поведение вне зависимости от время вызова функции

8. **Что такое TypeScript? Для чего введен? В чем отличие от JS?**

    TypeScript - это надстройка над JavaScript, добавляющая в язык строгую типизацию. Был введен для более безопасной и удобной разработки, позволяет решать много проблем кода еще на этапе разработки(или компиляции из TS в JS)
    Отличается от JS тем, что можно, зачастую - нужно, указать типы явно переменным, аргументам функции, возвращаемому значению функции, создать свои собственные типы и работать с ними

9. **Расскажите про базовые типы TypeScript**

    Есть как и знакомые из JS типы:

    - `number`
    - `string`
    - `boolean`
    - `object`
    - `bigint`
    - `symbol`
    - `null`
    - `undefined`
    - массивы(либо `type[]`, либо `Array<type>`)

    Так и особые от TS:

    - `enum` - перечисление констант
    - `any` - "любой тип", отменяет проверку типа
    - `unknown` - "неизвестный тип", переменную такого типа нельзя использовать, пока мы не убедимся, что она какого-либо типа
    - `tuple` - кортеж, то есть массив с заданной длиной и типами каждого элемента. Если добавить элемент не того типа не на свое место, то будет ошибка, однако добавлять элементы в кортеж можно
    - `never` - тип для функций никогда не возвращающих значения, либо выбрасывают ошибку, либо никогда не заканчивают выполнение
    - `void` - тип для функций, которые не возвращают значения

10. **Расскажите про обобщенные типы (generics) в TypeScript, приведите пару примеров.**

    Если использовать типизацию в TS, то, например функция

    ```ts
    function createPair(a: number, b: number): [number, number] {
    	return [a, b];
    }
    ```

    будет работать только с типом `number`, а с помощью обобщенных типов можно сделать эту функцию универсальной и передавать желаемый тип как бы как аргумент, например:

    ```ts
    function createPair<Type1, Type2>(a: Type1, b: Type2): [Type1, Type2] {
    	return [a, b];
    }

    createPair<number, string>(1, "1");
    createPair<boolean, boolean>(true, false);
    ```

    Теперь пользователь сам может задавать с какими типами будет работать функция

11. **Как сделать ряд свойств интерфейса необязательными? Как сделать все свойства интерфейса необязательными?**

    Просто добавить ? к названиям свойств, например:

    ```ts
    interface Example {
    	val1: number;
    	val2?: number;
    }
    ```

    Здесь я сделал свойство val2 необязательным

    Чтобы сделать все свойства необязательными можно навесить знак вопроса на каждое свойство или же сделать свой интерфейс, а объекту, который вы создаете через интерфейс назначить следующий тип:

    ```ts
    interface Example {
    	val1: number;
    	val2: number;
    }

    const example: Partial<Example>;
    ```

    Здесь используется встроенный тип TS, который делает все свойства переданного типа необязательными

12. **Для чего нужен тип “Omit” в TypeScript?**

    Это также встроенный тип в ts на ряду с `Partial`, который позволяет исключить из интерфейса введеные свойства, например:

    ```ts
    interface Example {
    	val1: number;
    	val2: number;
    }

    const example: Omit<Example, "val2"> = { val1: 1 };
    ```

13. **Возможно ли в TypeScript перегрузить функцию?**

    Да, для этого надо прописать, так называемые, сигнатуры функции, то есть все возможные варианты как мы хотим использовать одну и ту же функцию:

    ```ts
    function foo(a: number, b: number): number;
    function foo(a: number, b: string): number;
    ```

    А потом прописать одну реализацию этой функции, где надо проверить какие типы передались:

    ```ts
    function foo(a: number, b: string | number): number {
    	if (typeof b === "number") {
    		return a + b;
    	}
    	return a + Number(b);
    }
    ```
