# Деплой проекта

[ССЫЛКА НА САЙТ](http://xn----7sbfc0aehghsmbyr.xn--p1ai/)

# Тестовое задание (Frontend)
## Теоретические базовые знания

1. **Что такое «строгий режим»? Для чего он нужен?**
`"use strict"` или `'use strict'` - это директива, которая говорит JavaScript движку, что код далее нужно обрабатывать по новым стандартам, для включения "строгого режима" автоматически достаточно использовать модули или классы
Был введен для того, чтобы устаревший код продолжал работать, а в современном коде плохие практики старых стандратов выкидывали ошибку
Например, в строгом режиме нельзя объявлять переменную без ключевых слов `var`, `let` или `const`; нельзя для параметров функции использовать одинаковые имена и так далее

2. **Переменные – в чем отличие var, let, const? Когда и что предпочтительнее применять?**
    - `var` - устаревший способ объявления изменяемой переменной
    - `let` - современный способ объявления изменяемой переменной
    - `const` - способ объявляения неизменяемой переменной
Если мы предполагаем или видим, что в ходе выполнения кода переменная будет менять своё значение, нужно использовать `let`, иначе - `const`. Во всём остальном их поведение одинаково.
У `var` отличается поведение - `var` не имеет блочной видимости, то есть если объявить переменную в блоке `{...}`, то `var` будет доступна вне этого блока. Более того, инициализация переменных `var` происходит в начале исполнение кода, то есть можно сначала присвоить переменной значение, а потом её объявить и всё будет работать.

3. **Операторы сравнения**
    - **В чем отличие `==` от `===`; `!=` от `!==`?**
    `==` - нестрогое сравнение, преобразует операнды, которые сравниваются, в числа и потом возвращает результат сравнения
    `===` - строгое сравнение, если сравниваются разные типы сразу возвращает false
    Знаки `!=` и `!==` ведут себя аналогично
    - **Что будет в результате: '01' == 1 и '01' === 1? Почему?**
    `'01' == 1` вернет `true`, так как при преобразовании строки в число незначащие нули справа отбрасываются и получается в итоге `1 == 1`
    `'01' === 1` вернет `false`, так как сравниваются разные типы
    - **Что будет в результате: null === undefined и null == undefined? Почему?**
    `null === undefined` - будет `false` так как они относятся к разным типам
    `null == undefined` - будет `true`, потому что так специально в языке сделано
    - **Что будет в результате: null > 0; null == 0; null >= 0? Почему?**
    `null > 0` - вернет `false`, так как произойдет преобразование в число и получится `0 > 0`, что ложно
    `null >= 0` - вернет `true`, аналогично 
    `null == 0` - вернет `false`, потому что это также специально сделано в языке, что `null` не равно ничему другому, нестрого равно только `undefined`, чтобы было выше
    - **Что будет в результате: undefined > 0; undefined < 0; undefined == 0? Почему?** 
    `undefined > 0` - вернет `false`, потому что преобразование `undefined` в число даст `NaN`
    `undefined < 0` - вернет `false`, аналогично
    `undefined == 0` - вернет `false`, по тем же причинам, что и `null`, так как он нестрого равен только `null` 

4. **Функции: можно ли сохранить функцию в переменную?**
    Да, можно
    Например так:
    ```js 
    let foo = function() { let i = 1; };
    ```
    Или так:
    ```js
    function foo() { 
        let i = 1; 
    }

    let example = foo;
    ```

5. **Напишите функцию, которая реализует подтверждение опредленного действия (например, вы точно хотите удалить выбранный элемент?) в качестве параметров фукнция должна принимать: вопрос; функцию-колбэк, вызываемую если пользователь подтвердит действие; функциюколбэк, вызываемую, если пользователь отклонит действие. Для подтверждения пользователем – используйте стандартную функцию prompt.**

    Можно сделать так:

    ```js
        function OK_func() {
            console.log("Вроде согласились");
        }

        function Cancel_func() {
            console.log("Видимо, отказались")
        }

        function check(question, onOK, onCancel) {
            if(prompt(question + " Подсказка: ДА, чтобы продожить") === "ДА"){
                onOK();
            } else {
                onCancel();
            }
        }

        check("Вы точно этого хотите???", OK_func, Cancel_func);
        check("Точно-точно хотите?", () => { console.log("Вроде согласились"); }, () => { console.log("Видимо, отказались"); })
    ```

6. **Объекты, методы объектов, this. Что такое this? Приведите пример потери this. Приведите пример решения проблемы потери this через привязку контекста и стрелочные функции.**  
    Объект представляет собой ассоциативный массив, хранящий пары типа `ключ - значение`, его можно создать двумя способами:
     - `new Object()`
     - `{}`
    В качестве значения может быть любое значение - примитивы, объекты, функции(они называются методами объекта)

    `this` - ключевое слово, указывающее на тот объект, в контексте которого `this` было вызвано
    Контекст может потеряться, если мы передаем метод объекта с `this` как callback, например, если поменять немного код из прошлого вопроса:
    ```js
        const check_obj = {
            OK_text: "Вроде согласились",
            cancel_text: "Видимо, отказались",
            OK_func() {
                console.log(this.OK_text);
            },
            cancel_func() {
                console.log(this.cancel_text)
            }
        }

        function check(question, onOK, onCancel) {
            if(prompt(question + " Подсказка: ДА, чтобы продожить") === "ДА"){
                onOK();
            } else {
                onCancel();
            }
        }

        check("Вы точно этого хотите???", check_obj.OK_func, check_obj.cancel_func);
    ```

    Есть пути решения:
     - Привязка контекста через `bind`, где мы вручную передаем контекст и возвращаем функцию с нужным нам контекстом
        ```js
            const check_obj = {
                OK_text: "Вроде согласились",
                cancel_text: "Видимо, отказались",
                OK_func() {
                    console.log(this.OK_text);
                },
                cancel_func() {
                    console.log(this.cancel_text)
                }
            }

            function check(question, onOK, onCancel) {
                if(prompt(question + " Подсказка: ДА, чтобы продожить") === "ДА"){
                    onOK();
                } else {
                    onCancel();
                }
            }

            check("Вы точно этого хотите???", check_obj.OK_func.bind(check_obj), check_obj.cancel_func.bind(check_obj));
        ```
     - Использование стрелочных функций, которые не имеют своего контекста и, соответственно, не переопределяют контекст
        ```js
            const check_obj = {
            OK_text: "Вроде согласились",
            cancel_text: "Видимо, отказались",
            OK_func() {
                console.log(this.OK_text);
            },
            cancel_func() {
                console.log(this.cancel_text)
            }
        }

        function check(question, onOK, onCancel) {
            if(prompt(question + " Подсказка: ДА, чтобы продожить") === "ДА"){
                onOK();
            } else {
                onCancel();
            }
        }

        check("Вы точно этого хотите???", () => { check_obj.OK_func() }, () => { check_obj.cancel_func() });
        ```

7. **Планирование: setTimeout и setInterval. Для чего они используются? В чем отличие setInterval от рекурсивного setTimeout? Отмена timeout-а и interval-а.**

    Они используются для отложенного и регулярного выполнения функции, соответственно.
    Отмена осуществляется путем методов `clearInterval` и `clearTimeout`, в которые передаются id счетчиков, а id возвращаются из `setTimeout` и `setInterval`
    Рекурсивный `setTimeout` более гибок, в нем можно настроить свою логику регулярного выполнения, менять задержку как угодно, а самое важное, что если функция выполняется долго, то при `setInterval` время её выполнения пойдет в счет задержки, и если функция выполнилась за время бОльшее, чем задержка, то она выполнится повторно немедленно, а с рекурсивным `setTimeout` будет ожидамое поведение вне зависимости от время вызова функции

8. **Что такое TypeScript? Для чего введен? В чем отличие от JS?**

    TypeScript - это надстройка над JavaScript, добавляющая в язык строгую типизацию. Был введен для более безопасной и удобной разработки, позволяет решать много проблем кода еще на этапе разработки(или компиляции из TS в JS)
    Отличается от JS тем, что можно, зачастую - нужно, указать типы явно переменным, аргументам функции, возвращаемому значению функции, создать свои собственные типы и работать с ними

9. **Расскажите про базовые типы TypeScript**

    Есть как и знакомые из JS типы:

    - `number`
    - `string`
    - `boolean`
    - `object`
    - `bigint`
    - `symbol`
    - `null`
    - `undefined`
    - массивы(либо `type[]`, либо `Array<type>`)

    Так и особые от TS:

    - `enum` - перечисление констант
    - `any` - "любой тип", отменяет проверку типа
    - `unknown` - "неизвестный тип", переменную такого типа нельзя использовать, пока мы не убедимся, что она какого-либо типа
    - `tuple` - кортеж, то есть массив с заданной длиной и типами каждого элемента. Если добавить элемент не того типа не на свое место, то будет ошибка, однако добавлять элементы в кортеж можно
    - `never` - тип для функций никогда не возвращающих значения, либо выбрасывают ошибку, либо никогда не заканчивают выполнение
    - `void` - тип для функций, которые не возвращают значения

10. **Расскажите про обобщенные типы (generics) в TypeScript, приведите пару примеров.**

    Если использовать типизацию в TS, то, например функция

    ```ts
    function createPair(a: number, b: number): [number, number] {
    	return [a, b];
    }
    ```

    будет работать только с типом `number`, а с помощью обобщенных типов можно сделать эту функцию универсальной и передавать желаемый тип как бы как аргумент, например:

    ```ts
    function createPair<Type1, Type2>(a: Type1, b: Type2): [Type1, Type2] {
    	return [a, b];
    }

    createPair<number, string>(1, "1");
    createPair<boolean, boolean>(true, false);
    ```

    Теперь пользователь сам может задавать с какими типами будет работать функция

11. **Как сделать ряд свойств интерфейса необязательными? Как сделать все свойства интерфейса необязательными?**

    Просто добавить ? к названиям свойств, например:

    ```ts
    interface Example {
    	val1: number;
    	val2?: number;
    }
    ```

    Здесь я сделал свойство val2 необязательным

    Чтобы сделать все свойства необязательными можно навесить знак вопроса на каждое свойство или же сделать свой интерфейс, а объекту, который вы создаете через интерфейс назначить следующий тип:

    ```ts
    interface Example {
    	val1: number;
    	val2: number;
    }

    const example: Partial<Example>;
    ```

    Здесь используется встроенный тип TS, который делает все свойства переданного типа необязательными

12. **Для чего нужен тип “Omit” в TypeScript?**

    Это также встроенный тип в ts на ряду с `Partial`, который позволяет исключить из интерфейса введеные свойства, например:

    ```ts
    interface Example {
    	val1: number;
    	val2: number;
    }

    const example: Omit<Example, "val2"> = { val1: 1 };
    ```

13. **Возможно ли в TypeScript перегрузить функцию?**

    Да, для этого надо прописать, так называемые, сигнатуры функции, то есть все возможные варианты как мы хотим использовать одну и ту же функцию:

    ```ts
    function foo(a: number, b: number): number;
    function foo(a: number, b: string): number;
    ```

    А потом прописать одну реализацию этой функции, где надо проверить какие типы передались:

    ```ts
    function foo(a: number, b: string | number): number {
    	if (typeof b === "number") {
    		return a + b;
    	}
    	return a + Number(b);
    }
    ```
